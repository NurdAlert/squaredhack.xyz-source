// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

#include "exploit.h"
#include "../misc/prediction_system.h"
#include "..\ragebot\aim.h"

bool exploit::createmove(CUserCmd* m_pcmd)
{
	this->double_tap_deffensive(m_pcmd);

	return true;
}

void exploit::double_tap_deffensive(CUserCmd* m_pcmd)
{
	if (g_cfg.ragebot.defensive_doubletap)
		return;

	if (g_ctx.local()->m_vecVelocity().Length2D() < g_ctx.local()->GetMaxPlayerSpeed())
	{
		g_ctx.globals.m_Peek.m_bIsPeeking = false;
		g_ctx.globals.shift_time = g_ctx.local()->m_fFlags() & FL_ONGROUND ? 1 : 5;
		return;
	}

	// check weapon -- revolver off
	const auto pCombatWeapon = g_ctx.local()->m_hActiveWeapon().Get();

	if (!pCombatWeapon || pCombatWeapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER || (m_pcmd->m_buttons & IN_ATTACK))
		return;

	// predpos
	Vector predicted_eye_pos = g_ctx.globals.eye_pos + (engineprediction::get().backup_data.velocity * m_globals()->m_intervalpertick);

	for (auto i = 1; i <= m_globals()->m_maxclients; i++)
	{
		auto e = static_cast<player_t*>(m_entitylist()->GetClientEntity(i));
		if (!e->valid(true))
			continue;

		auto records = &player_records[i];
		if (records->empty())
			continue;

		auto record = &records->front();
		if (!record->valid())
			continue;

		// apply player animated data
		record->adjust_player();

		// look all ticks for get first hitable
		for (int next_chock = 1; next_chock <= m_clientstate()->iChokedCommands; ++next_chock)
		{
			predicted_eye_pos *= next_chock;

			auto fire_data = autowall::get().wall_penetration(predicted_eye_pos, e->hitbox_position_matrix(HITBOX_HEAD, record->matrixes_data.first), e);
			if (!fire_data.valid || fire_data.damage < 1)
				continue;

			g_ctx.globals.m_Peek.m_bIsPeeking = true;
		}
	}

	if (++g_ctx.globals.shift_time > 14)
		g_ctx.globals.shift_time = 0;

	if (g_ctx.local()->m_vecVelocity().Length2D() > 72)
		g_ctx.globals.shift_time = g_ctx.local()->m_fFlags() & FL_ONGROUND ? 2 : 4;

	if (g_ctx.globals.shift_time > m_clientstate()->iChokedCommands)
		std::clamp(g_ctx.globals.shift_time, 1, 2);


	if (g_ctx.globals.shift_time > 0)
		g_ctx.globals.tickbase_shift = g_ctx.globals.shift_time > 0 ? 14 : 0;
	    g_ctx.send_packet = true;

	if (m_gamerules()->m_bIsValveDS() || g_ctx.globals.m_Peek.m_bIsPeeking)
	{
		if (!g_ctx.globals.m_Peek.m_bIsPrevPeek)
		{
			g_ctx.globals.m_Peek.m_bIsPrevPeek = true;
			g_ctx.globals.tickbase_shift = 14;
			return;
		}
	}
	else
		g_ctx.globals.m_Peek.m_bIsPrevPeek = false;

	// break lc
	g_ctx.globals.tickbase_shift = 2;

	// shift time weave hello!
	++g_ctx.globals.shift_time = 14;
}

bool exploit::double_tap(CUserCmd* m_pcmd)
{
	double_tap_enabled = true;

	static auto recharge_double_tap = false;
	static auto last_double_tap = 0;

	if (recharge_double_tap)
	{
		recharge_double_tap = false;
		recharging_double_tap = true;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (recharging_double_tap)
	{
		auto recharge_time = g_ctx.globals.weapon->can_double_tap() ? TIME_TO_TICKS(0.45f) : TIME_TO_TICKS(0.60f);

		if (!aim::get().should_stop && fabs(g_ctx.globals.fixed_tickbase - last_double_tap) > recharge_time)
		{
			last_double_tap = 0;

			recharging_double_tap = false;
			double_tap_key = true;
		}
		else if (m_pcmd->m_buttons & IN_ATTACK)
			last_double_tap = g_ctx.globals.fixed_tickbase;
	}

	if (!g_cfg.ragebot.enable)
	{
		double_tap_enabled = false;
		double_tap_key = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (!g_cfg.ragebot.double_tap)
	{
		double_tap_enabled = false;
		double_tap_key = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (g_cfg.ragebot.double_tap_key.key <= KEY_NONE || g_cfg.ragebot.double_tap_key.key >= KEY_MAX)
	{
		double_tap_enabled = false;
		double_tap_key = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (double_tap_key && g_cfg.ragebot.double_tap_key.key != g_cfg.antiaim.hide_shots_key.key)
		hide_shots_key = false;

	if (!double_tap_key)
	{
		double_tap_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (g_ctx.local()->m_bGunGameImmunity() || g_ctx.local()->m_fFlags() & FL_FROZEN) //-V807
	{
		double_tap_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (m_gamerules()->m_bIsValveDS())
	{
		double_tap_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (g_ctx.globals.fakeducking)
	{
		double_tap_enabled = false;
		g_ctx.globals.ticks_allowed = 0;
		g_ctx.globals.next_tickbase_shift = 0;
		return false;
	}

	if (antiaim::get().freeze_check)
		return true;

	auto max_tickbase_shift = g_ctx.globals.weapon->get_max_tickbase_shift();

	if (!g_ctx.globals.weapon->is_grenade() && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_TASER && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_REVOLVER && g_ctx.send_packet && (m_pcmd->m_buttons & IN_ATTACK || m_pcmd->m_buttons & IN_ATTACK2 && g_ctx.globals.weapon->is_knife())) //-V648
	{
		auto next_command_number = m_pcmd->m_command_number + 1;
		auto user_cmd = m_input()->GetUserCmd(next_command_number);

		memcpy(user_cmd, m_pcmd, sizeof(CUserCmd)); 

		user_cmd->m_command_number = next_command_number;

		util::copy_command(user_cmd, max_tickbase_shift);

		if (g_ctx.globals.aimbot_working)
		{
			g_ctx.globals.double_tap_aim = true;
			g_ctx.globals.double_tap_aim_check = true;
		}

		recharge_double_tap = true;
		double_tap_enabled = false;
		double_tap_key = false;

		last_double_tap = g_ctx.globals.fixed_tickbase;
	}
	else if (!g_ctx.globals.weapon->is_grenade() && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_TASER && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_REVOLVER)
		g_ctx.globals.tickbase_shift = max_tickbase_shift;

	return true;
}

void exploit::hide_shots(CUserCmd* m_pcmd, bool should_work)
{
	{
		hide_shots_enabled = true;

		if (!g_cfg.ragebot.enable)
		{
			hide_shots_enabled = false;
			hide_shots_key = false;

			if (should_work)
			{
				g_ctx.globals.ticks_allowed = 0;
				g_ctx.globals.next_tickbase_shift = 0;
			}

			return;
		}

		if (!g_cfg.antiaim.hide_shots)
		{
			hide_shots_enabled = false;
			hide_shots_key = false;

			if (should_work)
			{
				g_ctx.globals.ticks_allowed = 0;
				g_ctx.globals.next_tickbase_shift = 0;
			}

			return;
		}

		if (g_cfg.antiaim.hide_shots_key.key <= KEY_NONE || g_cfg.antiaim.hide_shots_key.key >= KEY_MAX)
		{
			hide_shots_enabled = false;
			hide_shots_key = false;

			if (should_work)
			{
				g_ctx.globals.ticks_allowed = 0;
				g_ctx.globals.next_tickbase_shift = 0;
			}

			return;
		}

		if (!should_work && double_tap_key)
		{
			hide_shots_enabled = false;
			hide_shots_key = false;
			return;
		}

		if (!hide_shots_key)
		{
			hide_shots_enabled = false;
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
			return;
		}

		double_tap_key = false;

		if (g_ctx.local()->m_bGunGameImmunity() || g_ctx.local()->m_fFlags() & FL_FROZEN)
		{
			hide_shots_enabled = false;
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
			return;
		}

		if (g_ctx.globals.fakeducking)
		{
			hide_shots_enabled = false;
			g_ctx.globals.ticks_allowed = 0;
			g_ctx.globals.next_tickbase_shift = 0;
			return;
		}

		if (antiaim::get().freeze_check)
			return;

		g_ctx.globals.next_tickbase_shift = m_gamerules()->m_bIsValveDS() ? 6 : 9;

		auto revolver_shoot = g_ctx.globals.weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER && !g_ctx.globals.revolver_working && (m_pcmd->m_buttons & IN_ATTACK || m_pcmd->m_buttons & IN_ATTACK2);
		auto weapon_shoot = m_pcmd->m_buttons & IN_ATTACK && g_ctx.globals.weapon->m_iItemDefinitionIndex() != WEAPON_REVOLVER || m_pcmd->m_buttons & IN_ATTACK2 && g_ctx.globals.weapon->is_knife() || revolver_shoot;

		if (g_ctx.send_packet && !g_ctx.globals.weapon->is_grenade() && weapon_shoot)
			g_ctx.globals.tickbase_shift = g_ctx.globals.next_tickbase_shift;
	}
}